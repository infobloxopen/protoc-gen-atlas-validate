// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: example/examplepb/example.proto

package examplepb // import "github.com/infobloxopen/protoc-gen-atlas-validate/example/examplepb"

import fmt "fmt"
import http "net/http"
import json "encoding/json"
import ioutil "io/ioutil"
import bytes "bytes"
import context "golang.org/x/net/context"
import metadata "google.golang.org/grpc/metadata"
import runtime "github.com/grpc-ecosystem/grpc-gateway/runtime"
import validate_runtime "github.com/infobloxopen/protoc-gen-atlas-validate/runtime"
import google_protobuf1 "github.com/infobloxopen/protoc-gen-atlas-validate/example/external"
import proto "github.com/gogo/protobuf/proto"
import math "math"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/example/external"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"
import _ "google.golang.org/genproto/googleapis/api/annotations"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// validate_Users_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Users_Create_0.
func validate_Users_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_User(ctx, r, "", false)
}

// validate_Users_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Users_Update_0.
func validate_Users_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_User(ctx, r, "", false)
}

// validate_Users_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Users_Update_1.
func validate_Users_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_User(ctx, r, "", false)
}

// validate_Users_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Users_List_0.
func validate_Users_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("Body is not allowed")
	}
	return nil
}

// validate_Users_List_1 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Users_List_1.
func validate_Users_List_1(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("Body is not allowed")
	}
	return nil
}

// validate_Users_UpdateExternalUser_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Users_UpdateExternalUser_0.
func validate_Users_UpdateExternalUser_0(ctx context.Context, r json.RawMessage) (err error) {
	obj := google_protobuf1.ExternalUser{}
	if validator, ok := interface{}(obj).(interface {
		AtlasValidateJSON(context.Context, json.RawMessage, string, bool) error
	}); ok {
		return validator.AtlasValidateJSON(ctx, r, "", false)
	}
	return nil
}

// validate_Users_UpdateExternalUser2_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Users_UpdateExternalUser2_0.
func validate_Users_UpdateExternalUser2_0(ctx context.Context, r json.RawMessage) (err error) {
	obj := google_protobuf1.ExternalUser{}
	if validator, ok := interface{}(obj).(interface {
		AtlasValidateJSON(context.Context, json.RawMessage, string, bool) error
	}); ok {
		return validator.AtlasValidateJSON(ctx, r, "", false)
	}
	return nil
}

// validate_Profiles_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Profiles_Create_0.
func validate_Profiles_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Profile(ctx, r, "", false)
}

// validate_Profiles_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Profiles_Update_0.
func validate_Profiles_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Profile(ctx, r, "", true)
}

// validate_Groups_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Groups_Create_0.
func validate_Groups_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Group(ctx, r, "", true)
}

// validate_Groups_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Groups_Update_0.
func validate_Groups_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Group(ctx, r, "", true)
}

// validate_Groups_ValidatedList_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Groups_ValidatedList_0.
func validate_Groups_ValidatedList_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("Body is not allowed")
	}
	return nil
}

// validate_Groups_ValidatedList_1 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Groups_ValidatedList_1.
func validate_Groups_ValidatedList_1(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("Body is not allowed")
	}
	return nil
}

// validate_Object_User function validates a JSON for a given object.
func validate_Object_User(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &User{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "id":
			method := validate_runtime.HTTPMethodFromContext(ctx)
			if "POST" == method {
				return fmt.Errorf("Field %s unsupported for create method", k)
			}
		case "name":
		case "profile":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			if err = validate_Object_Profile(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		case "address":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			if err = validate_Object_Address(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		case "groups":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := validate_runtime.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("Invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Group(ctx, vv, vvPath, allowUnknown); err != nil {
					return err
				}
			}
		case "parents":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := validate_runtime.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("Invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_User_Parent(ctx, vv, vvPath, allowUnknown); err != nil {
					return err
				}
			}
		case "external_user":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			validator, ok := interface{}(&google_protobuf1.ExternalUser{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string, bool) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object User.
func (o *User) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_User(ctx, r, path, allowUnknown)
}

// validate_Object_User_Parent function validates a JSON for a given object.
func validate_Object_User_Parent(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &User_Parent{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "name":
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object User_Parent.
func (o *User_Parent) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_User_Parent(ctx, r, path, allowUnknown)
}

// validate_Object_Address function validates a JSON for a given object.
func validate_Object_Address(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &Address{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "country":
		case "state":
			return fmt.Errorf("Field %s has readonly access", k)
		case "city":
		case "zip":
		case "tags":
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Address.
func (o *Address) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_Address(ctx, r, path, allowUnknown)
}

// validate_Object_Group function validates a JSON for a given object.
func validate_Object_Group(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &Group{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "id":
		case "name":
		case "notes":
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Group.
func (o *Group) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_Group(ctx, r, path, allowUnknown)
}

// validate_Object_CreateUserRequest function validates a JSON for a given object.
func validate_Object_CreateUserRequest(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &CreateUserRequest{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			if err = validate_Object_User(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateUserRequest.
func (o *CreateUserRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_CreateUserRequest(ctx, r, path, allowUnknown)
}

// validate_Object_UpdateUserRequest function validates a JSON for a given object.
func validate_Object_UpdateUserRequest(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &UpdateUserRequest{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			if err = validate_Object_User(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateUserRequest.
func (o *UpdateUserRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_UpdateUserRequest(ctx, r, path, allowUnknown)
}

// validate_Object_EmptyRequest function validates a JSON for a given object.
func validate_Object_EmptyRequest(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &EmptyRequest{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object EmptyRequest.
func (o *EmptyRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_EmptyRequest(ctx, r, path, allowUnknown)
}

// validate_Object_EmptyResponse function validates a JSON for a given object.
func validate_Object_EmptyResponse(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &EmptyResponse{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object EmptyResponse.
func (o *EmptyResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_EmptyResponse(ctx, r, path, allowUnknown)
}

// validate_Object_Profile function validates a JSON for a given object.
func validate_Object_Profile(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &Profile{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "id":
		case "name":
			method := validate_runtime.HTTPMethodFromContext(ctx)
			if "PUT" == method || "PATCH" == method {
				return fmt.Errorf("Field %s unsupported for update method", k)
			}
		case "notes":
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Profile.
func (o *Profile) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_Profile(ctx, r, path, allowUnknown)
}

// validate_Object_UpdateProfileRequest function validates a JSON for a given object.
func validate_Object_UpdateProfileRequest(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	obj := &UpdateProfileRequest{}
	if hook, ok := interface{}(obj).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("Invalid value for %q: expected object.", path)
	}
	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := validate_runtime.JoinPath(path, k)
			if err = validate_Object_Profile(ctx, vv, vvPath, allowUnknown); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("Unknown field %q", validate_runtime.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateProfileRequest.
func (o *UpdateProfileRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string, allowUnknown bool) (err error) {
	if hook, ok := interface{}(o).(interface {
		AtlasJSONValidate(json.RawMessage, string, bool) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(r, path, allowUnknown); err != nil {
			return err
		}
	}
	return validate_Object_UpdateProfileRequest(ctx, r, path, allowUnknown)
}

var validate_Patterns = []struct {
	pattern    runtime.Pattern
	httpMethod string
	validator  func(context.Context, json.RawMessage) error
	// Included for introspection purpose.
	allowUnknown bool
}{
	{
		pattern:      pattern_Users_Create_0,
		httpMethod:   "POST",
		validator:    validate_Users_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Users_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Users_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_List_0,
		httpMethod:   "GET",
		validator:    validate_Users_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_List_1,
		httpMethod:   "GET",
		validator:    validate_Users_List_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_UpdateExternalUser_0,
		httpMethod:   "PUT",
		validator:    validate_Users_UpdateExternalUser_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Users_UpdateExternalUser2_0,
		httpMethod:   "PUT",
		validator:    validate_Users_UpdateExternalUser2_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Profiles_Create_0,
		httpMethod:   "POST",
		validator:    validate_Profiles_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Profiles_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Profiles_Update_0,
		allowUnknown: true,
	},
	{
		pattern:      pattern_Groups_Create_0,
		httpMethod:   "POST",
		validator:    validate_Groups_Create_0,
		allowUnknown: true,
	},
	{
		pattern:      pattern_Groups_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Groups_Update_0,
		allowUnknown: true,
	},
	{
		pattern:      pattern_Groups_ValidatedList_0,
		httpMethod:   "GET",
		validator:    validate_Groups_ValidatedList_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Groups_ValidatedList_1,
		httpMethod:   "GET",
		validator:    validate_Groups_ValidatedList_1,
		allowUnknown: false,
	},
}

// AtlasValidateAnnotator parses JSON input and validates unknown fields
// based on 'allow_unknown_fields' options specified in proto file.
func AtlasValidateAnnotator(ctx context.Context, r *http.Request) metadata.MD {
	md := make(metadata.MD)
	for _, v := range validate_Patterns {
		if r.Method == v.httpMethod && validate_runtime.PatternMatch(v.pattern, r.URL.Path) {
			var b []byte
			var err error
			if b, err = ioutil.ReadAll(r.Body); err != nil {
				md.Set("Atlas-Validation-Error", "Invalid value: unable to parse body")
				return md
			}
			r.Body = ioutil.NopCloser(bytes.NewReader(b))
			ctx := context.WithValue(context.Background(), "http-method", r.Method)
			if err = v.validator(ctx, b); err != nil {
				md.Set("Atlas-Validation-Error", err.Error())
			}
			break
		}
	}
	return md
}
